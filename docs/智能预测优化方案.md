# 智能预测系统 - 算法分析与优化建议

## 目录

- [一、现有算法实现分析](#一现有算法实现分析)
- [二、参考指标体系](#二参考指标体系)
- [三、准确度优化方案](#三准确度优化方案)
- [四、可结合的新增指标](#四可结合的新增指标)
- [五、实施建议](#五实施建议)

---

## 一、现有算法实现分析

### 1.1 系统架构概览

```
┌─────────────────────────────────────────────────────────────────────┐
│                    ComprehensivePredictor (综合预测器)               │
├─────────────────────────────────────────────────────────────────────┤
│                                                                     │
│  ┌──────────────────┐  ┌──────────────────┐  ┌──────────────────┐  │
│  │ QuickPrediction  │  │ QuickPriceRange  │  │ SignalGenerator  │  │
│  │ Model            │  │ Predictor        │  │                  │  │
│  │ (方向预测)        │  │ (价格区间预测)    │  │ (交易信号生成)    │  │
│  └────────┬─────────┘  └────────┬─────────┘  └────────┬─────────┘  │
│           │                     │                     │            │
│           ▼                     ▼                     ▼            │
│  ┌─────────────────────────────────────────────────────────────┐   │
│  │              FeatureEngineer (特征工程)                       │   │
│  │  • 收益率特征  • 动量特征  • 波动率特征  • 成交量特征          │   │
│  │  • 趋势特征    • K线形态特征  • 技术指标特征                   │   │
│  └─────────────────────────────────────────────────────────────┘   │
│           │                     │                     │            │
│           ▼                     ▼                     ▼            │
│  ┌─────────────────────────────────────────────────────────────┐   │
│  │              IndicatorCalculator (技术指标计算器)              │   │
│  │  MA | EMA | MACD | RSI | KDJ | BOLL | ATR | OBV              │   │
│  └─────────────────────────────────────────────────────────────┘   │
│                                                                     │
│  ┌─────────────────────────────────────────────────────────────┐   │
│  │          SentimentAnalysisService (情感分析服务)               │   │
│  │  新闻爬取 → 中文情感词典 → 情感得分 → 市场情绪                  │   │
│  └─────────────────────────────────────────────────────────────┘   │
└─────────────────────────────────────────────────────────────────────┘
```

### 1.2 方向预测模型 (QuickPredictionModel)

**算法类型**: 基于规则的多因子评分模型

**实现原理**:
1. 计算多个技术指标的当前值
2. 根据预设规则为每个指标打分（-1 到 +1）
3. 计算加权平均得分
4. 根据得分阈值判断方向

**代码位置**: `backend/app/ml/models/price_direction.py`

**当前评分规则**:
```python
# MA趋势: MA5 > MA20 → +1, MA5 < MA20 → -1
# RSI: < 30 → +0.5, > 70 → -0.5
# MACD: 红柱增长 → +1, 绿柱增长 → -1
# KDJ: K > D 且 K < 80 → +0.5
# 成交量: 放量上涨 → +0.5, 放量下跌 → -0.5
```

**优点**:
- 计算速度快，无需训练
- 逻辑清晰，可解释性强
- 适合实时预测

**缺点**:
- 规则固定，无法自适应市场变化
- 权重人为设定，可能不是最优
- 未考虑指标之间的非线性关系

### 1.3 价格区间预测 (QuickPriceRangePredictor)

**算法类型**: 基于历史波动率的统计预测

**实现原理**:
1. 计算历史日收益率
2. 计算波动率（标准差）
3. 使用正态分布假设计算置信区间
4. 根据近期趋势估算预期价格

**代码位置**: `backend/app/ml/models/price_range.py`

**核心公式**:
```
日波动率 σ = std(日收益率)
N日波动率 = σ × √N  (根号时间法则)
价格区间 = 当前价格 × (1 ± Z × N日波动率)
```

**优点**:
- 计算简单，有统计学理论支撑
- 可以给出不同置信水平的区间

**缺点**:
- 假设收益率服从正态分布（实际常有肥尾）
- 未考虑趋势变化
- 波动率使用历史值，可能滞后

### 1.4 交易信号生成器 (SignalGenerator)

**算法类型**: 多维度加权评分模型

**实现原理**:
1. 五个维度独立评分
2. 按权重加权求和
3. 根据阈值生成信号
4. 基于ATR计算止损止盈

**代码位置**: `backend/app/ml/models/signal_generator.py`

**权重配置**:
```python
技术指标分析: 30%
趋势分析: 25%
动量分析: 20%
波动率分析: 15%
成交量分析: 10%
```

### 1.5 情感分析 (ChineseSentimentAnalyzer)

**算法类型**: 基于词典的情感分析

**实现原理**:
1. 使用AKShare获取新闻
2. 基于预定义的积极/消极词典匹配
3. 考虑程度副词和否定词
4. 计算综合情感得分

**代码位置**: `backend/app/sentiment/sentiment_analyzer.py`

**词典规模**:
- 积极词汇: ~40个
- 消极词汇: ~40个
- 程度副词: ~10个
- 否定词: ~6个

---

## 二、参考指标体系

### 2.1 当前使用的技术指标

| 类别 | 指标 | 参数 | 用途 |
|------|------|------|------|
| **趋势类** | MA | 5, 10, 20, 60 | 判断趋势方向 |
| | EMA | 12, 26 | MACD计算基础 |
| **动量类** | MACD | (12,26,9) | 趋势动量 |
| | RSI | 14 | 超买超卖 |
| | KDJ | (9,3,3) | 超买超卖+趋势 |
| **波动类** | BOLL | (20,2) | 波动区间 |
| | ATR | 14 | 真实波幅 |
| **量价类** | Volume MA | 5, 20 | 量能变化 |
| | OBV | - | 量价关系 |

### 2.2 当前使用的特征

| 类别 | 特征 | 窗口 | 说明 |
|------|------|------|------|
| **收益率** | return_Nd | 1,5,10,20,60 | N日收益率 |
| | log_return_1d | 1 | 对数收益率 |
| **动量** | momentum_Nd | 5,10,20,60 | 价格动量 |
| | roc_Nd | 5,10,20,60 | 变化率 |
| | price_position_Nd | 5,10,20,60 | 相对位置 |
| **波动率** | volatility_Nd | 5,10,20,60 | 收益率标准差 |
| | atr_Nd | 5,10,20,60 | 归一化ATR |
| | amplitude_Nd | 5,10,20,60 | 价格振幅 |
| **成交量** | volume_ratio_Nd | 5,10,20,60 | 量比 |
| | volume_std_Nd | 5,10,20,60 | 量能波动 |
| | price_volume_corr_Nd | 5,10,20,60 | 量价相关性 |
| **趋势** | trend_slope_Nd | 5,10,20,60 | 线性回归斜率 |
| | up_days_ratio_Nd | 5,10,20,60 | 上涨天数比 |
| | consecutive_trend | 20 | 连续涨跌天数 |
| **K线形态** | body_ratio | - | 实体比例 |
| | upper_shadow_ratio | - | 上影线比例 |
| | lower_shadow_ratio | - | 下影线比例 |
| | is_bullish | - | 阳线/阴线 |
| | gap_up/down | - | 跳空缺口 |

---

## 三、准确度优化方案

### 3.1 模型层面优化

#### 3.1.1 引入机器学习模型

**现状**: 当前使用基于规则的评分模型

**优化方案**: 引入有监督学习模型

```python
# 推荐模型选择
┌──────────────┬────────────┬───────────────────────┐
│ 模型         │ 适用场景    │ 优势                   │
├──────────────┼────────────┼───────────────────────┤
│ LightGBM     │ 方向分类    │ 速度快、精度高          │
│ XGBoost      │ 方向分类    │ 鲁棒性强               │
│ CatBoost     │ 分类/回归   │ 处理类别特征好          │
│ LSTM         │ 序列预测    │ 捕捉时序依赖           │
│ Transformer  │ 序列预测    │ 并行计算、长期依赖      │
└──────────────┴────────────┴───────────────────────┘
```

**实现建议**:
```python
# 1. 训练LightGBM分类器（已有代码基础）
class PriceDirectionModel:
    def train(self, X_train, y_train):
        # 使用交叉验证优化参数
        params = {
            'objective': 'binary',
            'metric': 'auc',
            'learning_rate': 0.05,
            'num_leaves': 31,
            'feature_fraction': 0.8,
            'bagging_fraction': 0.8,
        }
        # 训练并保存模型

# 2. 添加时序交叉验证
from sklearn.model_selection import TimeSeriesSplit
tscv = TimeSeriesSplit(n_splits=5)
```

#### 3.1.2 集成学习

**方案**: 多模型融合提高预测稳定性

```python
# 集成预测器
class EnsemblePredictor:
    def __init__(self):
        self.models = [
            QuickPredictionModel(),   # 规则模型
            LGBMClassifier(),          # LightGBM
            RandomForestClassifier(),  # 随机森林
        ]
        self.weights = [0.3, 0.4, 0.3]

    def predict(self, X):
        predictions = []
        for model in self.models:
            pred = model.predict_proba(X)[:, 1]
            predictions.append(pred)

        # 加权平均
        final_pred = np.average(predictions, weights=self.weights, axis=0)
        return final_pred
```

#### 3.1.3 特征选择优化

**方案**: 使用特征重要性分析筛选最优特征

```python
# 特征选择流程
1. 计算所有特征
2. 训练LightGBM获取feature_importance
3. 剔除重要性低的特征（减少噪声）
4. 使用递归特征消除（RFE）进一步优化
5. 保留Top 30-50个特征
```

### 3.2 数据层面优化

#### 3.2.1 标签优化

**现状**: 简单的涨跌二分类

**优化方案**: 多分类 + 回归结合

```python
# 方案1: 三分类（涨/跌/震荡）
def create_labels_3class(df, forward_days=5, threshold=0.02):
    future_return = df['close'].shift(-forward_days) / df['close'] - 1
    labels = pd.Series(1, index=df.index)  # 默认震荡
    labels[future_return > threshold] = 2   # 涨
    labels[future_return < -threshold] = 0  # 跌
    return labels

# 方案2: 多任务学习
# 同时预测方向和幅度
class MultiTaskModel:
    def predict(self, X):
        direction = self.direction_model.predict(X)
        magnitude = self.regression_model.predict(X)
        return direction, magnitude
```

#### 3.2.2 数据增强

```python
# 时间序列数据增强
1. 添加噪声: X_aug = X + np.random.normal(0, 0.01, X.shape)
2. 时间扭曲: 对时间序列进行微小的时间缩放
3. 滑动窗口: 使用不同起始点生成更多训练样本
```

#### 3.2.3 样本平衡

```python
# 解决涨跌样本不平衡
from imblearn.over_sampling import SMOTE

smote = SMOTE(random_state=42)
X_resampled, y_resampled = smote.fit_resample(X_train, y_train)
```

### 3.3 评分规则优化

#### 3.3.1 动态权重

**现状**: 固定权重

**优化方案**: 根据市场状态动态调整权重

```python
class DynamicSignalGenerator:
    def get_weights(self, df):
        # 判断市场状态
        volatility = self._calculate_volatility(df)
        trend_strength = self._calculate_trend_strength(df)

        if volatility > 0.4:  # 高波动市场
            return {
                'technical': 0.35,  # 增加技术指标权重
                'trend': 0.20,
                'momentum': 0.15,
                'volatility': 0.20,  # 增加波动率权重
                'volume': 0.10
            }
        elif trend_strength > 0.6:  # 强趋势市场
            return {
                'technical': 0.25,
                'trend': 0.35,  # 增加趋势权重
                'momentum': 0.25,  # 增加动量权重
                'volatility': 0.10,
                'volume': 0.05
            }
        else:  # 震荡市场
            return {
                'technical': 0.30,
                'trend': 0.25,
                'momentum': 0.20,
                'volatility': 0.15,
                'volume': 0.10
            }
```

#### 3.3.2 阈值自适应

```python
# 基于历史数据自动计算最优阈值
def optimize_threshold(scores, labels):
    best_threshold = 0
    best_accuracy = 0

    for threshold in np.arange(0.1, 0.8, 0.05):
        predictions = (scores > threshold).astype(int)
        accuracy = (predictions == labels).mean()

        if accuracy > best_accuracy:
            best_accuracy = accuracy
            best_threshold = threshold

    return best_threshold
```

### 3.4 情感分析优化

#### 3.4.1 扩展情感词典

```python
# 当前词典规模较小，建议扩展
EXTENDED_POSITIVE_WORDS = [
    # 原有词汇 + 新增
    '放量突破', '底部放量', '主力吸筹', '资金抢筹', '涨停板',
    '业绩预增', '高送转', '重组', '并购', '战略合作',
    '产能扩张', '订单增加', '市占率提升', '龙头地位',
    '技术突破', '专利获批', '新产品发布', '客户拓展',
    # ... 扩展至200+词汇
]

EXTENDED_NEGATIVE_WORDS = [
    # 原有词汇 + 新增
    '天量见顶', '放量滞涨', '主力出货', '资金撤离', '跌停板',
    '业绩预亏', '商誉减值', '资产减值', '计提坏账', '债务违约',
    '产能过剩', '订单减少', '市占率下降', '竞争加剧',
    '技术落后', '专利诉讼', '产品召回', '客户流失',
    # ... 扩展至200+词汇
]
```

#### 3.4.2 引入预训练模型

```python
# 使用中文预训练模型提升准确度
# 推荐: FinBERT-Chinese 或 RoBERTa-wwm-ext

from transformers import BertTokenizer, BertForSequenceClassification

class AdvancedSentimentAnalyzer:
    def __init__(self):
        self.tokenizer = BertTokenizer.from_pretrained('hfl/chinese-roberta-wwm-ext')
        self.model = BertForSequenceClassification.from_pretrained(
            'ProsusAI/finbert',  # 或使用中文金融BERT
            num_labels=3
        )

    def analyze(self, text):
        inputs = self.tokenizer(text, return_tensors='pt', truncation=True)
        outputs = self.model(**inputs)
        scores = torch.softmax(outputs.logits, dim=1)
        return scores  # [负面, 中性, 正面]
```

---

## 四、可结合的新增指标

### 4.1 高优先级指标（强烈建议添加）

#### 4.1.1 资金流向指标

| 指标 | 说明 | 获取方式 |
|------|------|---------|
| **主力资金净流入** | 大单买入-卖出 | AKShare |
| **北向资金** | 外资流向 | AKShare |
| **融资融券余额** | 杠杆资金变化 | AKShare |

```python
# 实现示例
def get_money_flow_features(code):
    """获取资金流向特征"""
    import akshare as ak

    # 主力资金
    main_flow = ak.stock_individual_fund_flow(stock=code)

    # 北向资金
    north_flow = ak.stock_hsgt_north_net_flow_in_em()

    return {
        'main_net_inflow': main_flow['主力净流入'].iloc[-1],
        'main_net_inflow_5d': main_flow['主力净流入'].tail(5).sum(),
        'north_net_inflow': north_flow['北向资金'].iloc[-1],
    }
```

#### 4.1.2 市场情绪指标

| 指标 | 说明 | 获取方式 |
|------|------|---------|
| **涨跌停比** | 涨停数/跌停数 | 计算 |
| **涨跌家数比** | 上涨家数/下跌家数 | AKShare |
| **恐慌指数(VIX)** | 波动率指数 | 无直接A股VIX，可用期权隐含波动率 |

```python
def get_market_sentiment_features():
    """获取市场情绪特征"""
    import akshare as ak

    # 涨跌停统计
    zt_df = ak.stock_zt_pool_em()  # 涨停池
    dt_df = ak.stock_dt_pool_em()  # 跌停池

    zt_count = len(zt_df)
    dt_count = len(dt_df)

    return {
        'zt_count': zt_count,
        'dt_count': dt_count,
        'zt_dt_ratio': zt_count / (dt_count + 1),  # 避免除0
        'sentiment_score': (zt_count - dt_count) / (zt_count + dt_count + 1)
    }
```

#### 4.1.3 行业相对强弱

```python
def get_industry_features(code):
    """获取行业相对强弱"""
    import akshare as ak

    # 获取股票所属行业
    industry = get_stock_industry(code)

    # 获取行业涨跌幅
    industry_df = ak.stock_board_industry_index_em()

    # 计算相对强弱
    stock_return = get_stock_return(code, days=5)
    industry_return = industry_df[industry_df['板块'] == industry]['涨跌幅'].iloc[0]

    return {
        'industry_return': industry_return,
        'relative_strength': stock_return - industry_return,
        'industry_rank': get_industry_rank(industry)  # 行业排名
    }
```

### 4.2 中优先级指标

#### 4.2.1 筹码分布指标

| 指标 | 说明 | 用途 |
|------|------|------|
| **获利盘比例** | 当前价格下获利筹码占比 | 压力位判断 |
| **套牢盘比例** | 当前价格上套牢筹码占比 | 支撑位判断 |
| **筹码集中度** | 筹码分布集中程度 | 主力控盘度 |

```python
def calculate_chip_distribution(df, current_price):
    """计算筹码分布（简化版）"""
    # 近期成交分布作为筹码分布的近似
    recent_df = df.tail(60)

    # 计算各价格区间的成交量
    price_bins = np.linspace(df['low'].min(), df['high'].max(), 20)
    volume_dist = np.zeros(len(price_bins) - 1)

    for _, row in recent_df.iterrows():
        for i in range(len(price_bins) - 1):
            if price_bins[i] <= row['close'] < price_bins[i+1]:
                volume_dist[i] += row['volume']

    # 获利盘比例
    profit_chips = volume_dist[price_bins[:-1] < current_price].sum()
    total_chips = volume_dist.sum()
    profit_ratio = profit_chips / total_chips if total_chips > 0 else 0

    return {
        'profit_ratio': profit_ratio,
        'lock_ratio': 1 - profit_ratio,
        'chip_concentration': np.std(volume_dist) / np.mean(volume_dist)
    }
```

#### 4.2.2 市场微观结构指标

| 指标 | 说明 | 用途 |
|------|------|------|
| **委比** | (委买量-委卖量)/(委买量+委卖量) | 短期买卖力量 |
| **量价背离** | 价格创新高/低但量能未配合 | 趋势反转信号 |
| **大单占比** | 大单成交占总成交比例 | 主力动向 |

#### 4.2.3 期权数据（如适用）

| 指标 | 说明 | 用途 |
|------|------|------|
| **Put/Call Ratio** | 看跌/看涨期权比率 | 市场情绪 |
| **隐含波动率** | 期权价格反推的波动率 | 市场预期 |
| **期权持仓量变化** | 期权市场资金动向 | 大资金预期 |

### 4.3 低优先级（未来扩展）

#### 4.3.1 宏观经济指标

| 指标 | 说明 | 更新频率 |
|------|------|---------|
| **M2增速** | 货币供应增速 | 月度 |
| **社融增量** | 社会融资增量 | 月度 |
| **PMI** | 制造业采购经理指数 | 月度 |
| **CPI/PPI** | 物价指数 | 月度 |
| **利率** | 国债收益率、LPR | 实时/月度 |

#### 4.3.2 另类数据

| 数据源 | 说明 | 用途 |
|--------|------|------|
| **搜索指数** | 百度指数、微信指数 | 关注度 |
| **社交媒体** | 微博、雪球讨论量 | 情绪 |
| **卫星数据** | 停车场车辆、工厂开工 | 基本面 |

### 4.4 指标整合建议

```python
class EnhancedFeatureEngineer:
    """增强版特征工程"""

    def generate_all_features(self, df, code):
        features = {}

        # 原有特征
        features.update(self.calculate_price_features(df))
        features.update(self.calculate_technical_features(df))

        # 新增特征 - 高优先级
        features.update(self.get_money_flow_features(code))
        features.update(self.get_market_sentiment_features())
        features.update(self.get_industry_features(code))

        # 新增特征 - 中优先级
        features.update(self.calculate_chip_distribution(df))
        features.update(self.get_microstructure_features(code))

        return features
```

---

## 五、实施建议

### 5.1 优化路线图

```
Phase 1 (1-2周): 快速提升
├── 扩展情感词典 (200+词汇)
├── 添加资金流向特征
├── 添加市场情绪特征
└── 优化评分权重

Phase 2 (2-4周): 模型升级
├── 训练LightGBM分类模型
├── 实现时序交叉验证
├── 特征重要性分析与筛选
└── 集成学习融合

Phase 3 (1-2月): 深度优化
├── 引入BERT情感分析
├── 添加行业/筹码特征
├── 动态权重系统
└── A/B测试框架

Phase 4 (持续): 长期改进
├── 模型自动重训练
├── 监控预测准确率
├── 持续添加新特征
└── 用户反馈优化
```

### 5.2 效果评估方法

```python
class PredictionEvaluator:
    """预测效果评估器"""

    def evaluate(self, predictions, actuals):
        metrics = {}

        # 方向准确率
        metrics['direction_accuracy'] = (
            (predictions['direction'] == actuals['direction']).mean()
        )

        # 信号准确率
        metrics['signal_accuracy'] = self._calculate_signal_accuracy(
            predictions['signal'], actuals['return']
        )

        # 价格区间覆盖率
        metrics['range_coverage'] = self._calculate_range_coverage(
            predictions['price_range'], actuals['price']
        )

        # 情感分析准确率
        metrics['sentiment_correlation'] = np.corrcoef(
            predictions['sentiment'], actuals['return']
        )[0, 1]

        # 收益回测
        metrics['strategy_return'] = self._backtest_strategy(
            predictions, actuals
        )

        return metrics
```

### 5.3 预期效果

| 优化项 | 当前预估准确率 | 优化后预期 | 提升幅度 |
|--------|--------------|-----------|---------|
| 方向预测 | ~55% | 60-65% | +5-10% |
| 信号准确率 | ~50% | 55-60% | +5-10% |
| 价格区间覆盖 | ~70% | 80-85% | +10-15% |
| 情感相关性 | ~0.2 | 0.3-0.4 | +50-100% |

### 5.4 注意事项

1. **避免过拟合**:
   - 使用时序交叉验证
   - 保持训练/测试数据时间分离
   - 特征不宜过多

2. **数据质量**:
   - 处理缺失值和异常值
   - 注意AKShare数据延迟
   - 定期更新数据源

3. **模型更新**:
   - 定期重训练（建议每周/每月）
   - 监控预测漂移
   - 保存模型版本

4. **风险控制**:
   - 预测仅供参考
   - 设置置信度阈值
   - 结合其他分析方法

---

## 附录：代码参考

### A.1 增强版特征工程

```python
# backend/app/ml/enhanced_features.py

class EnhancedFeatureEngineer:
    """增强版特征工程类"""

    @staticmethod
    def get_money_flow_features(code: str) -> dict:
        """获取资金流向特征"""
        try:
            import akshare as ak

            # 个股资金流向
            flow_df = ak.stock_individual_fund_flow(stock=code, market='sh')

            latest = flow_df.iloc[-1]
            return {
                'main_net_inflow': float(latest.get('主力净流入', 0)),
                'retail_net_inflow': float(latest.get('散户净流入', 0)),
                'main_net_inflow_5d': float(flow_df['主力净流入'].tail(5).sum()),
            }
        except Exception as e:
            return {'main_net_inflow': 0, 'retail_net_inflow': 0, 'main_net_inflow_5d': 0}

    @staticmethod
    def get_market_breadth() -> dict:
        """获取市场广度指标"""
        try:
            import akshare as ak

            # 涨跌统计
            market_df = ak.stock_zh_a_spot_em()

            up_count = (market_df['涨跌幅'] > 0).sum()
            down_count = (market_df['涨跌幅'] < 0).sum()
            zt_count = (market_df['涨跌幅'] >= 9.9).sum()
            dt_count = (market_df['涨跌幅'] <= -9.9).sum()

            return {
                'up_count': int(up_count),
                'down_count': int(down_count),
                'up_down_ratio': float(up_count / (down_count + 1)),
                'zt_count': int(zt_count),
                'dt_count': int(dt_count),
                'market_sentiment': float((up_count - down_count) / (up_count + down_count + 1))
            }
        except Exception as e:
            return {'up_count': 0, 'down_count': 0, 'market_sentiment': 0}
```

### A.2 集成预测器

```python
# backend/app/ml/ensemble_predictor.py

class EnsemblePredictor:
    """集成预测器"""

    def __init__(self):
        self.rule_model = QuickPredictionModel()
        self.ml_model = None  # 训练后加载
        self.weights = {'rule': 0.4, 'ml': 0.6}

    def predict(self, df: pd.DataFrame) -> dict:
        # 规则模型预测
        rule_result = self.rule_model.predict(df)
        rule_score = rule_result.get('score', 0)

        # ML模型预测（如果已训练）
        ml_score = 0
        if self.ml_model is not None:
            features = FeatureEngineer.generate_all_features(df)
            ml_prob = self.ml_model.predict_proba(features.iloc[[-1]])[:, 1]
            ml_score = (ml_prob[0] - 0.5) * 2  # 转换为-1到1

        # 加权融合
        final_score = (
            rule_score * self.weights['rule'] +
            ml_score * self.weights['ml']
        )

        return {
            'score': float(final_score),
            'rule_score': float(rule_score),
            'ml_score': float(ml_score),
            'direction': 1 if final_score > 0.3 else (-1 if final_score < -0.3 else 0),
            'confidence': float(min(abs(final_score), 1))
        }
```

---

## 版本信息

- **文档版本**: 1.0.0
- **更新日期**: 2024年1月
- **作者**: AI Stock Analysis System
